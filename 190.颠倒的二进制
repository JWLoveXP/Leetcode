颠倒给定的 32 位无符号整数的二进制位。 
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
方法1：遍历32位，数字右移，遇到为1的数字则把该数字颠倒，right记录颠倒后的数字左移位数
时间复杂度0(32) = O(1), 空间复杂度O(1)
uint32_t reverseBits(uint32_t n) {
	int right = 31;
	int res = 0;
	while(n > 0)
	{
		if ((n&1) == 1)
			res += 1 << right;
		n >>= 1;
		right--;
	}
	return res;
}
方法2；分治的思想，
首先，我们将原来的 32 位分为 2 个 16 位的块。
然后我们将 16 位块分成 2 个 8 位的块。
然后我们继续将这些块分成更小的块，直到达到 1 位的块。
在上述每个步骤中，我们将中间结果合并为一个整数，作为下一步的输入。
uint32_t reverseBits(uint32_t n) {
    n = (n >> 16) | (n << 16);
    n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);
    n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);
    n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);
    n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);
    return n;
}
时间复杂度O(1)，系数更小, 空间复杂度O(1)
