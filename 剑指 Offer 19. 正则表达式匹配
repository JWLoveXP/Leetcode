请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。
例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

方法:动态规划。dp[i][j]代表s[0,i-1]和p[0,j-1]是否匹配，因为在最前面需要添加空集的情况，对于s[i]和p[j],如果s[i] == p[j] || p[j] == '.'，dp[i + 1][j + 1] = dp[i][j],
对于p[j] == '*'，有两种情况，一种s[i] != p[j - 1] && p[j - 1] != '.'，也就是说'*'前面的字符和s[i]不适配，那么只能选择前面的字符为0个，此时dp[i + 1][j + 1] = dp[i + 1][j - 1];
第二种适配的情况，此时有多种可能，此时能选择的情况为0个，1个和多个，0个dp[i + 1][j - 1]，去掉前面的字符，1个dp[i + 1][j]，多个dp[i][j + 1]，多于多个的情况，如aabb和aab*,此时，s[3] != p[2]，如果
dp[3][4] = true，即aab和aab*适配，那么多个的情况也适配，相当于多个的情况是s字符串退一步
bool isMatch(string s, string p) {
	int m = s.size();
	int n = p.size();
	vector<vector<bool>>dp(m + 1, vector<bool>(n + 1, false));
	dp[0][0] = true; //空集
	int i, j;
	for (i = 0; i < n; i++)
	{
		if (p[i] == '*')
			dp[0][i + 1] = dp[0][i - 1];
	}
	for (i = 0; i < m; i++)
	{
		for (j = 0; j < n; j++)
		{
			if (s[i] == p[j] || p[j] == '.')
				dp[i + 1][j + 1] = dp[i][j];
			else if (p[j] == '*')
			{
				if (s[i] != p[j - 1] && p[j - 1] != '.') //不相等的情况，只能去掉
					dp[i + 1][j + 1] = dp[i + 1][j - 1];
				else
					dp[i + 1][j + 1] = dp[i + 1][j - 1] || dp[i + 1][j] || dp[i][j + 1];
			}
		}
	}
	return dp[m][n];
}
