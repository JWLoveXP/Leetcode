给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。

进阶:
如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？


如果链表很大甚至会超过内存，此时应该如何实现等概率选中？

有一个算法可以实现，那就是蓄水池算法。
假如选择1个节点，那么从左到右遍历时，对于链表中的第 i 个节点有 1/i 	概论被选中
对于第一个节点1，只能选择它，概率p = 1
对于第二个节点2，选择它的概率为1/2，前一个选择的节点留下的概概率为 1*（1/2） = 1/2
对于第三个节点3，选择它的概率为1/3，剩下的节点留下的概概率为 (1/2)*(2/3) = 1/3
对于第 i 个节点，选择它的概率为1/i，剩下的节点留下的概概率为 (1/i-1)*(i-1/i) = 1/i

从而最终留下节点的概率为1/n


假如选择k个节点，那么从左到右遍历时，对于i<=k，保留对于链表中的第 i 个节点有 k/i 	概率被选中
，k个节点中算计选择一个置换

对于第k+1个节点，如果不保留该节点，则剩下的节点的概率为1*1/(k+1),如果保留了该节点，那么前 k 的节点保留的概率为(k-1)/k * k/(k+1)，所以剩下节点的概率为两者之和，即k/k+1
对于第k+2个节点，如果不保留该节点，则剩下的节点的概率为k/(k+1)*2/(k+2),如果保留了该节点，那么前k+1节点中保留的概率为k-1/k+1 * k/(k+2)，所以剩下节点的概率为两者之和，即k/k+2

对于第 i 个节点，如果不保留该节点，则剩下的节点的概率为k/(i-1)*(i-k)/i如果保留了该节点，那么前i-1节点中保留的概率为k-1/i-1 * k/i，所以剩下节点的概率为两者之和，即k/i

从而最终留下节点的概率为k/n

所以对于随机等概率抽取k个点，首先保留前k个节点，然后对于第i个节点，以k/i的概率替换保留的某个节点，在保留节点中以1/k的概率选择

代码
class Solution {
public:
	/** @param head The linked list's head.
	Note that the head is guaranteed to be not null, so it contains at least one node. */
	
	ListNode* start; 
	Solution(ListNode* head) {
		start = head;
	}

	/** Returns a random node's value. */
	int getRandom() {
		int count = 1;
		ListNode* p = start;
		ListNode* res;
		int num;
		while (p)
		{
			num = rand() % count;
			if (num == count - 1)
				res = p;
			p = p->next;
			count++;
		}
		return res->val;
	}
};
